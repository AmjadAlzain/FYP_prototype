#include "embhd_esp32.h"
#include <string.h>
#include <math.h>
#include "esp_heap_caps.h"

// Include pre-trained model headers (will be generated by Python script)
#include "embhd_projection.h"
#include "embhd_prototypes.h"

static const char* TAG = EMBHD_ESP32_LOG_TAG;

// Check if PSRAM is available and allocate memory accordingly
static void* embhd_esp32_malloc(size_t size, bool* using_psram) {
    void* ptr = NULL;
    
#if CONFIG_ESP32S3_SPIRAM_SUPPORT
    if (EMBHD_ESP32_USE_PSRAM && esp_spiram_is_initialized()) {
        // Try to allocate from PSRAM first
        ptr = heap_caps_malloc(size, MALLOC_CAP_SPIRAM);
        if (ptr) {
            *using_psram = true;
            return ptr;
        }
    }
#endif

    // Fall back to regular RAM
    ptr = malloc(size);
    *using_psram = false;
    return ptr;
}

esp_err_t embhd_esp32_init(embhd_esp32_context_t* ctx, 
                          uint32_t in_features, 
                          uint32_t num_classes,
                          uint32_t hd_dim,
                          embhd_vtype_t vtype) {
    if (!ctx) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Clear context
    memset(ctx, 0, sizeof(embhd_esp32_context_t));
    
    // Initialize EmbHD model
    int ret = embhd_model_init(&ctx->model, in_features, num_classes, hd_dim, vtype);
    if (ret != 0) {
        ESP_LOGE(TAG, "Failed to initialize EmbHD model: %d", ret);
        return ESP_FAIL;
    }
    
    // Allocate scores array
    ctx->last_scores = malloc(num_classes * sizeof(float));
    if (!ctx->last_scores) {
        embhd_model_free(&ctx->model);
        return ESP_ERR_NO_MEM;
    }
    
    ctx->initialized = true;
    ctx->last_prediction = -1;
    
    ESP_LOGI(TAG, "EmbHD model initialized: %lu features, %lu classes, %lu dimensions", 
             (unsigned long)in_features, (unsigned long)num_classes, (unsigned long)hd_dim);
    
    return ESP_OK;
}

void embhd_esp32_deinit(embhd_esp32_context_t* ctx) {
    if (!ctx || !ctx->initialized) {
        return;
    }
    
    // Free EmbHD model
    embhd_model_free(&ctx->model);
    
    // Free scores array
    if (ctx->last_scores) {
        free(ctx->last_scores);
        ctx->last_scores = NULL;
    }
    
    ctx->initialized = false;
    ctx->last_prediction = -1;
    
    ESP_LOGI(TAG, "EmbHD model deinitialized");
}

esp_err_t embhd_esp32_init_from_headers(embhd_esp32_context_t* ctx) {
    if (!ctx) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Clear context
    memset(ctx, 0, sizeof(embhd_esp32_context_t));
    
    // Initialize model with dimensions from headers
    esp_err_t err = embhd_esp32_init(ctx, EMBHD_IN_FEATURES, EMBHD_NUM_CLASSES, 
                                   EMBHD_OUT_FEATURES, EMBHD_BIPOLAR);
    if (err != ESP_OK) {
        return err;
    }
    
    // Copy projection matrix
    for (uint32_t i = 0; i < EMBHD_IN_FEATURES; i++) {
        for (uint32_t j = 0; j < EMBHD_OUT_FEATURES; j++) {
            ctx->model.projection.weights[i * EMBHD_OUT_FEATURES + j] = proj_matrix[i][j];
        }
    }
    
    // Copy prototypes
    for (uint32_t i = 0; i < EMBHD_NUM_CLASSES; i++) {
        for (uint32_t j = 0; j < EMBHD_VECTOR_DIM; j++) {
            ctx->model.prototypes.vectors[i].data.bipolar[j] = prototypes[i][j];
        }
    }
    
    ESP_LOGI(TAG, "EmbHD model initialized from headers: %d features, %d classes, %d dimensions", 
             EMBHD_IN_FEATURES, EMBHD_NUM_CLASSES, EMBHD_OUT_FEATURES);
    
    return ESP_OK;
}

int8_t embhd_esp32_predict(embhd_esp32_context_t* ctx, 
                         const float* features, 
                         float* scores) {
    if (!ctx || !ctx->initialized || !features) {
        return -1;
    }
    
    // Predict using EmbHD model
    uint32_t prediction = embhd_predict(&ctx->model, features, ctx->last_scores);
    
    // Copy scores if requested
    if (scores) {
        memcpy(scores, ctx->last_scores, ctx->model.prototypes.num_classes * sizeof(float));
    }
    
    ctx->last_prediction = (int8_t)prediction;
    return ctx->last_prediction;
}

esp_err_t embhd_esp32_train_sample(embhd_esp32_context_t* ctx,
                                 const float* features,
                                 uint32_t class_id,
                                 float learning_rate) {
    if (!ctx || !ctx->initialized || !features) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (class_id >= ctx->model.prototypes.num_classes) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Train model on this sample
    embhd_train_sample(&ctx->model, features, class_id, learning_rate);
    
    ESP_LOGI(TAG, "Trained EmbHD model on sample for class %lu", (unsigned long)class_id);
    
    return ESP_OK;
}

esp_err_t embhd_esp32_get_memory_usage(embhd_esp32_context_t* ctx,
                                     uint32_t* ram_usage,
                                     uint32_t* psram_usage) {
    if (!ctx || !ctx->initialized) {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (ram_usage) {
        *ram_usage = 0;
    }
    
    if (psram_usage) {
        *psram_usage = 0;
    }
    
    // Calculate projection matrix size
    uint32_t proj_size = ctx->model.projection.in_features * 
                         ctx->model.projection.out_features * 
                         sizeof(float);
    
    // Calculate prototypes size
    uint32_t proto_size = 0;
    switch (ctx->model.prototypes.type) {
        case EMBHD_BINARY:
            proto_size = ctx->model.prototypes.num_classes * 
                        ((ctx->model.prototypes.dim + 7) / 8) * 
                        sizeof(uint8_t);
            break;
        case EMBHD_BIPOLAR:
            proto_size = ctx->model.prototypes.num_classes * 
                        ctx->model.prototypes.dim * 
                        sizeof(int8_t);
            break;
        case EMBHD_FLOAT:
            proto_size = ctx->model.prototypes.num_classes * 
                        ctx->model.prototypes.dim * 
                        sizeof(float);
            break;
    }
    
    // Add scores array size
    uint32_t scores_size = ctx->model.prototypes.num_classes * sizeof(float);
    
    // Add context size
    uint32_t ctx_size = sizeof(embhd_esp32_context_t);
    
    // Total size
    uint32_t total_size = proj_size + proto_size + scores_size + ctx_size;
    
    if (ctx->using_psram) {
        if (psram_usage) {
            *psram_usage = total_size;
        }
    } else {
        if (ram_usage) {
            *ram_usage = total_size;
        }
    }
    
    ESP_LOGI(TAG, "EmbHD memory usage: Total %lu bytes", (unsigned long)total_size);
    
    return ESP_OK;
}
