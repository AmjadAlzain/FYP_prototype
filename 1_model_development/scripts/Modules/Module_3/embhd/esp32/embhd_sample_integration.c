/**
 * EmbHD Sample Integration for ESP32-S3-EYE
 * 
 * This file demonstrates how to integrate EmbHD with the ESP32-S3-EYE
 * for marine debris classification using HDC.
 */

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_timer.h"

// EmbHD includes
#include "embhd_esp32.h"

// Headers generated by training script
#include "embhd_projection.h"
#include "embhd_prototypes.h"

static const char* TAG = "embhd-sample";

// Feature extraction function declaration (provided elsewhere, e.g. from CNN)
extern esp_err_t extract_features(const uint8_t* image_data, 
                                 uint32_t width, 
                                 uint32_t height, 
                                 float* features);

// Classification result structure
typedef struct {
    int8_t class_id;
    float confidence;
    uint32_t inference_time_us;
} classification_result_t;

// EmbHD context
static embhd_esp32_context_t embhd_ctx;
static bool embhd_initialized = false;

/**
 * Initialize EmbHD model
 */
esp_err_t initialize_embhd(void) {
    if (embhd_initialized) {
        ESP_LOGI(TAG, "EmbHD already initialized");
        return ESP_OK;
    }
    
    ESP_LOGI(TAG, "Initializing EmbHD model...");
    esp_err_t ret = embhd_esp32_init_from_headers(&embhd_ctx);
    
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize EmbHD model: %d", ret);
        return ret;
    }
    
    embhd_initialized = true;
    
    // Print memory usage
    uint32_t ram_usage = 0, psram_usage = 0;
    embhd_esp32_get_memory_usage(&embhd_ctx, &ram_usage, &psram_usage);
    ESP_LOGI(TAG, "EmbHD memory usage: RAM: %lu bytes, PSRAM: %lu bytes", 
             (unsigned long)ram_usage, (unsigned long)psram_usage);
    
    return ESP_OK;
}

/**
 * Classify an image using EmbHD
 */
esp_err_t classify_image(const uint8_t* image_data, 
                        uint32_t width, 
                        uint32_t height, 
                        classification_result_t* result) {
    if (!embhd_initialized) {
        ESP_LOGE(TAG, "EmbHD not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    if (!image_data || !result) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Allocate feature buffer
    float features[EMBHD_IN_FEATURES];
    
    // Extract features from image
    ESP_LOGI(TAG, "Extracting features...");
    esp_err_t ret = extract_features(image_data, width, height, features);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Feature extraction failed: %d", ret);
        return ret;
    }
    
    // Allocate scores array
    float scores[EMBHD_NUM_CLASSES];
    
    // Measure inference time
    int64_t start_time = esp_timer_get_time();
    
    // Classify using EmbHD
    int8_t prediction = embhd_esp32_predict(&embhd_ctx, features, scores);
    
    // Calculate inference time
    int64_t end_time = esp_timer_get_time();
    uint32_t inference_time = (uint32_t)(end_time - start_time);
    
    if (prediction < 0) {
        ESP_LOGE(TAG, "Classification failed");
        return ESP_FAIL;
    }
    
    // Find confidence score for the predicted class
    float confidence = scores[prediction];
    
    // Fill result structure
    result->class_id = prediction;
    result->confidence = confidence;
    result->inference_time_us = inference_time;
    
    ESP_LOGI(TAG, "Classification result: class=%d, confidence=%.4f, time=%lu us", 
             prediction, confidence, (unsigned long)inference_time);
    
    return ESP_OK;
}

/**
 * Train EmbHD model on a new example (on-device learning)
 */
esp_err_t train_embhd_sample(const uint8_t* image_data, 
                           uint32_t width, 
                           uint32_t height, 
                           uint8_t class_id) {
    if (!embhd_initialized) {
        ESP_LOGE(TAG, "EmbHD not initialized");
        return ESP_ERR_INVALID_STATE;
    }
    
    if (!image_data || class_id >= EMBHD_NUM_CLASSES) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Allocate feature buffer
    float features[EMBHD_IN_FEATURES];
    
    // Extract features from image
    ESP_LOGI(TAG, "Extracting features for training...");
    esp_err_t ret = extract_features(image_data, width, height, features);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Feature extraction failed: %d", ret);
        return ret;
    }
    
    // Train on this sample
    ESP_LOGI(TAG, "Training on sample for class %d", class_id);
    ret = embhd_esp32_train_sample(&embhd_ctx, features, class_id, 0.1f);
    
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Training failed: %d", ret);
        return ret;
    }
    
    ESP_LOGI(TAG, "Training successful");
    return ESP_OK;
}

/**
 * Example of how to use EmbHD in a FreeRTOS task
 */
void embhd_task(void* pvParameters) {
    // Initialize EmbHD
    if (initialize_embhd() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize EmbHD");
        vTaskDelete(NULL);
        return;
    }
    
    // Main loop
    while (1) {
        // This is where you would:
        // 1. Capture an image from the camera
        // 2. Classify it using EmbHD
        // 3. Display the result on the screen
        // 4. Optionally allow the user to train the model on new examples
        
        // Simulate a delay between operations
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

/**
 * Initialize and start EmbHD task
 */
esp_err_t start_embhd_task(void) {
    BaseType_t ret = xTaskCreate(
        embhd_task,                // Task function
        "embhd_task",              // Task name
        4096,                      // Stack size
        NULL,                      // Parameters
        5,                         // Priority
        NULL                       // Task handle
    );
    
    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create EmbHD task");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "EmbHD task started");
    return ESP_OK;
}

/**
 * Integration example with Module 6 (GUI)
 */
void embhd_gui_integration_example(void) {
    // Example of how to integrate with Module 6 (GUI)
    // This is pseudocode that would be adapted to work with the actual GUI implementation
    
    /*
    // 1. Initialize EmbHD
    initialize_embhd();
    
    // 2. Register classification callback with GUI
    gui_register_classify_callback(classify_image);
    
    // 3. Register training callback with GUI
    gui_register_training_callback(train_embhd_sample);
    
    // 4. Start the GUI
    start_gui();
    */
}
